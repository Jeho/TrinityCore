diff --git a/sql/custom/ruby_sanctum.sql b/sql/custom/ruby_sanctum.sql
new file mode 100644
index 0000000..f255d63
--- /dev/null
+++ b/sql/custom/ruby_sanctum.sql
@@ -0,0 +1,13 @@
+UPDATE `creature_template` SET `ScriptName` = 'boss_halion' WHERE `entry`= '39863';
+UPDATE `creature_template` SET `ScriptName` = 'boss_twilight_halion' WHERE `entry` = '40142';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_strike', `flags_extra`=128 WHERE `entry` = '40041';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_flame', `flags_extra`=128 WHERE `entry` = '40042';
+UPDATE `creature_template` SET `ScriptName` = 'npc_spell_meteor_strike', `flags_extra`=128 WHERE `entry` = '40029';
+UPDATE `creature_template` SET `ScriptName` = 'npc_summon_halion', `flags_extra`=128 WHERE `entry` = '40044';
+UPDATE `creature_template` SET `ScriptName` = 'npc_combustion' WHERE `entry` = '40001';
+INSERT INTO `spell_linked_spell` VALUES (-74562, 74610, 0, 'Fiery Combustion removed -> Combustion');
+INSERT INTO `spell_linked_spell` VALUES (-74792, 74800, 0, 'Soul Consumption removed -> Consumption');
+INSERT INTO `creature`(id, map, spawnMask, phaseMask, modelid, equipment_id, position_x, position_y, position_z, orientation, spawntimesecs, spawndist, currentwaypoint, curhealth, curmana, MovementType, npcflag, unit_flags, dynamicflags)
+VALUES (39863,724,15,65535,0,0,3144.93,527.233,72.8887,0.110395,604800,0,0,11156000,0,0,0,0,0);
+INSERT INTO `spell_script_names` VALUES (74812,'spell_halion_portal');
+UPDATE `gameobject_template` SET `data10`=74807 WHERE `entry`=202794;
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index fd90efe..6584de4 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -486,6 +486,7 @@ void AddSC_ruby_sanctum();
 void AddSC_boss_baltharus_the_warborn();
 void AddSC_boss_saviana_ragefire();
 void AddSC_boss_general_zarithrian();
+void AddSC_boss_halion();
 
 void AddSC_dalaran();
 void AddSC_borean_tundra();
@@ -1189,6 +1190,7 @@ void AddNorthrendScripts()
     AddSC_boss_baltharus_the_warborn();
     AddSC_boss_saviana_ragefire();
     AddSC_boss_general_zarithrian();
+    AddSC_boss_halion();
 
     AddSC_dalaran();
     AddSC_borean_tundra();
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index bff648e..c699794 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -50,6 +50,7 @@ set(scripts_STAT_SRCS
   Northrend/ChamberOfAspects/RubySanctum/boss_baltharus_the_warborn.cpp
   Northrend/ChamberOfAspects/RubySanctum/boss_saviana_ragefire.cpp
   Northrend/ChamberOfAspects/RubySanctum/boss_general_zarithrian.cpp
+  Northrend/ChamberOfAspects/RubySanctum/boss_halion.cpp
   Northrend/FrozenHalls/HallsOfReflection/halls_of_reflection.h
   Northrend/FrozenHalls/HallsOfReflection/boss_falric.cpp
   Northrend/FrozenHalls/HallsOfReflection/instance_halls_of_reflection.cpp
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_halion.cpp b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_halion.cpp
new file mode 100644
index 0000000..1151dd8
--- /dev/null
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/boss_halion.cpp
@@ -0,0 +1,904 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eTexts
+{
+    SAY_SPAWN       = -1752027,
+    SAY_AGGRO       = -1752028,
+    SAY_SLAY1       = -1752029,
+    SAY_SLAY2       = -1752030,
+    SAY_DEATH       = -1752031,
+    SAY_BERSERK     = -1752032,
+    SAY_SPECIAL1    = -1752033,
+    SAY_SPECIAL2    = -1752034,
+    SAY_PHASE2      = -1752035,
+    SAY_PHASE3      = -1752036
+};
+
+enum eSpells
+{
+    SPELL_FIRE_PILLAR               = 76006,
+    SPELL_FIERY_EXPLOSION           = 76010,
+    // All
+    SPELL_TWILIGHT_PRECISION        = 78243,
+    SPELL_CLEAVE                    = 74524,
+    SPELL_TAIL_LASH                 = 74531,
+    SPELL_BERSEK                    = 26662,
+    SPELL_TWILIGHT_DIVISION         = 75063,
+    SPELL_SUMMON_TWILIGHT_PORTAL    = 74809,
+
+    SPELL_METEOR_TARGET             = 74641,
+    SPELL_METEOR_STRIKE             = 74637,
+    SPELL_METEOR_DAMAGE             = 74648,
+    SPELL_METEOR_FLAME              = 74713,
+
+    // Halion
+    SPELL_FLAME_BREATH_10_NORMAL    = 74525,
+    SPELL_FLAME_BREATH_25_NORMAL    = 74526,
+    SPELL_FLAME_BREATH_10_HEROIC    = 74527,
+    SPELL_FLAME_BREATH_25_HEROIC    = 74528,
+    SPELL_FIERY_COMBUSTION          = 74562,
+
+    // Twilight Halion
+    SPELL_DUSK_SHROUD               = 75476,
+    SPELL_SOUL_CONSUMPTION          = 74792,
+    SPELL_DARK_BREATH_10_NORMAL     = 74806,
+    SPELL_DARK_BREATH_25_NORMAL     = 75954,
+    SPELL_DARK_BREATH_10_HEROIC     = 75955,
+    SPELL_DARK_BREATH_25_HEROIC     = 75956,
+
+    SPELL_AURE_TWILIGHT             = 74807,
+    SPELL_ROOT 			    = 42716,
+    SPELL_COMBUSTION 		    = 74629,
+};
+
+struct SpellsCorporeality
+{
+    uint32 SpellId1;
+    uint32 SpellId2;
+};
+
+static const SpellsCorporeality sCorporeality[11] =
+{
+    {74827, 74832},
+    {74828, 74833},
+    {74829, 74834},
+    {74830, 74835},
+    {74831, 74836},
+    {74832, 74827},
+    {74833, 74828},
+    {74834, 74829},
+    {74835, 74830},
+    {74836, 74831},
+    {74826, 74826}
+};
+
+enum eEvents
+{
+    EVENT_CAST_TWILIGHT_PRECISION   = 1,
+    EVENT_CAST_CLEAVE               = 2,
+    EVENT_CAST_FIERY_COMBUSTION     = 3,
+    EVENT_CAST_TAIL_LASH            = 4,
+    EVENT_CAST_FLAME_BREATH         = 5,
+    EVENT_CAST_DARK_BREATH          = 6,
+    EVENT_CAST_SOUL_CONSUMPTION     = 7,
+    EVENT_CAST_DUSK_SHROUD          = 8,
+    EVENT_FLAME_WALL                = 9,
+    EVENT_CAST_BERSEK               = 10,
+    EVENT_DPS                       = 11,
+    EVENT_METEOR_STRIKE             = 12,
+    EVENT_METEOR_DAMAGE             = 13,
+    EVENT_METEOR_FLAME              = 14,
+    EVENT_FIRE_PILLAR               = 15
+};
+
+enum ePhases
+{
+    PHASE_ALL = 0,
+    PHASE_1   = 1,
+    PHASE_2   = 2,
+    PHASE_3   = 3,
+
+    PHASE_1_MASK  = 1 << PHASE_1,
+    PHASE_2_MASK  = 1 << PHASE_2,
+    PHASE_3_MASK  = 1 << PHASE_3
+};
+
+Creature* pHalion;
+Creature* pTwilight;
+uint32 HalionDamage, TwilightDamage;
+uint32 HalionAura, TwilightAura;
+
+class boss_halion : public CreatureScript
+{
+    public:
+        boss_halion() : CreatureScript("boss_halion") { }
+
+        struct boss_halionAI : public BossAI
+        {
+            boss_halionAI(Creature *pCreature) : BossAI(pCreature, DATA_HALION)
+                {
+                    ASSERT(instance);
+                    pHalion = me;
+                }
+
+            void Reset()
+            {
+                if (instance->GetData(DATA_TWILIGHT_HALION)==IN_PROGRESS || instance->GetBossState(DATA_HALION)==IN_PROGRESS)
+                    return;
+
+                instance->SetBossState(DATA_HALION, NOT_STARTED);
+                events.Reset();
+                events.SetPhase(PHASE_1);
+                events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1000);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000));
+                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000);
+                events.ScheduleEvent(EVENT_METEOR_STRIKE, 20000);
+                events.ScheduleEvent(SPELL_BERSEK, 600000);
+                PercentDamage = 0;
+                HalionDamage = 0;
+                HalionAura = 0;
+                RemoveAllGO();
+            }
+
+            void RemoveAllGO()
+            {
+                if (GameObject* flame1 = GetClosestGameObjectWithEntry(me, GO_FLAME_RING, 1000.0f))
+                {
+                    flame1->SetPhaseMask(2,true);
+                    flame1->RemoveFromWorld();
+                }
+
+                if (GameObject* flame2 = GetClosestGameObjectWithEntry(me, GO_FLAME_WALLS3, 1000.0f))
+                {
+                    flame2->SetPhaseMask(2,true);
+                    flame2->RemoveFromWorld();
+                }
+
+                if (GameObject* portal1 = GetClosestGameObjectWithEntry(me, GO_HALION_PORTAL_1, 1000.0f))
+                    portal1->RemoveFromWorld();
+
+                if (GameObject* portal2 = GetClosestGameObjectWithEntry(me, GO_HALION_PORTAL_EXIT, 1000.0f))
+                    portal2->RemoveFromWorld();
+            }
+
+            void MeteorStrike()
+            {
+                float x,y,z;
+                Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM,0);
+                if (pTarget)
+                {
+                    pTarget->GetPosition(x,y,z);
+                    me->SummonCreature(NPC_METEOR_STRIKE_NORTH, x, y, z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 999999);
+                }
+            }
+
+            void EnterCombat(Unit*)
+            {
+                instance->SetBossState(DATA_HALION, IN_PROGRESS);
+                
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    return;
+                }
+                
+                events.ScheduleEvent(EVENT_FLAME_WALL, 3000,0,PHASE_1);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void CastCorporeality()
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                uint32 TotalDamage = HalionDamage+TwilightDamage;
+                if (TotalDamage > 0)
+                {
+                    PercentDamage = HalionDamage * 100 / TotalDamage;
+                }
+                else
+                {
+                    PercentDamage = 50;
+                }
+                HalionDamage = 0;
+                TwilightDamage = 0;
+                if (TwilightAura!=0)
+                {
+                    pTwilight->RemoveAurasDueToSpell(TwilightAura);
+                }
+                if (HalionAura!=0)
+                {
+                    pHalion->RemoveAurasDueToSpell(HalionAura);
+                }
+
+                uint8 idAura;
+                if (PercentDamage < 5)
+                {
+                    idAura = 9;
+                }
+                else if (PercentDamage < 15)
+                {
+                    idAura = 8;
+                }
+                else if (PercentDamage < 25)
+                {
+                    idAura = 7;
+                }
+                else if (PercentDamage < 35)
+                {
+                    idAura = 6;
+                }
+                else if (PercentDamage < 45)
+                {
+                    idAura = 5;
+                }
+                else if (PercentDamage < 55)
+                {
+                    idAura = 10;
+                }
+                else if (PercentDamage < 65)
+                {
+                    idAura = 0;
+                }
+                else if (PercentDamage < 75)
+                {
+                    idAura = 1;
+                }
+                else if (PercentDamage < 85)
+                {
+                    idAura = 2;
+                }
+                else if (PercentDamage < 95)
+                {
+                    idAura = 3;
+                }
+                else
+                {
+                    idAura = 4;
+                }
+                pHalion->CastSpell(pHalion, sCorporeality[idAura].SpellId1, true);
+                pTwilight->CastSpell(pTwilight, sCorporeality[idAura].SpellId2, true);
+                HalionAura=sCorporeality[idAura].SpellId1;
+                TwilightAura=sCorporeality[idAura].SpellId2;
+            }
+
+            void SetPhase3()
+            {
+                events.SetPhase(PHASE_3);
+                if (GameObject* portal = me->SummonGameObject(GO_HALION_PORTAL_EXIT, 3154.56f, 535.418f, 72.8889f, 4.47206f, 0, 0, 0.786772f, -0.617243f, 99999999))
+                {
+                    portal->SetPhaseMask(32,true);
+                    portal->SetRespawnTime(9999999);
+                }
+                events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                pHalion->SetHealth(pTwilight->GetHealth());
+            }
+
+            void DamageTaken(Unit* /*who*/, uint32 &dmg)
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                HalionDamage += dmg;    
+                
+                instance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+            }
+
+            void JustSummoned(Creature *summon)
+            {
+                if (summon->GetEntry()==NPC_HALION_TWILIGHT)
+                {
+                    summon->SetPhaseMask(32,true);
+                    summons.Summon(summon);
+                }
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustReachedHome()
+            {
+                instance->SetBossState(DATA_HALION,FAIL);
+                RemoveAllGO();
+                me->SetVisible(true);
+                me->SetReactState(REACT_AGGRESSIVE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                instance->SetData(DATA_HALION, DONE);
+                instance->SetBossState(DATA_HALION, DONE);
+                RemoveAllGO();
+                _JustDied();
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+                DoScriptText(SAY_DEATH, me);
+                switch(instance->instance->GetDifficulty())
+                {
+                    case RAID_DIFFICULTY_10MAN_NORMAL:
+			class achievement_twilight_destroyer_normal_10 : public AchievementCriteriaScript
+			{ 
+			  public: 
+				achievement_twilight_destroyer_normal_10() : AchievementCriteriaScript("achievement_twilight_destroyer_normal_10")
+			{
+			}
+		};
+		    RemoveAllGO();
+		    break;				
+                    case RAID_DIFFICULTY_10MAN_HEROIC:
+			class achievement_twilight_destroyer_heroic_10 : public AchievementCriteriaScript
+			{
+			  public:
+				achievement_twilight_destroyer_heroic_10() : AchievementCriteriaScript("achievement_twilight_destroyer_heroic_10")
+			{
+			}
+		};
+		    RemoveAllGO();
+		    break;				
+                    case RAID_DIFFICULTY_25MAN_NORMAL:
+			class achievement_twilight_destroyer_normal_25 : public AchievementCriteriaScript
+			{
+			  public:
+				achievement_twilight_destroyer_normal_25() : AchievementCriteriaScript("achievement_twilight_destroyer_normal_25")
+			{
+			}
+		};
+		    RemoveAllGO();
+		    break;				
+                    case RAID_DIFFICULTY_25MAN_HEROIC:
+			class achievement_twilight_destroyer_heroic_25 : public AchievementCriteriaScript
+			{
+			  public:
+				achievement_twilight_destroyer_heroic_25() : AchievementCriteriaScript("achievement_twilight_destroyer_heroic_25")
+			{
+			}
+		};
+		    RemoveAllGO();
+		    break;				
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (instance->GetData(DATA_DAMAGE) > 0)
+                        me->SetHealth(instance->GetData(DATA_DAMAGE));
+                    else
+                        if (instance->GetData(DATA_TWILIGHT_HALION)==IN_PROGRESS)
+                            me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                if ((events.GetPhaseMask() & PHASE_1_MASK) || (events.GetPhaseMask() & PHASE_3_MASK))
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_TWILIGHT_PRECISION:
+                                DoCast(me, SPELL_TWILIGHT_PRECISION); // not working
+                                me->AddAura(SPELL_TWILIGHT_PRECISION, me); //test
+                                break;
+                            case EVENT_FLAME_WALL:
+                                if (GameObject* go_flame1 = me->SummonGameObject(GO_FLAME_RING, 3154.56f, 535.418f, 72.8889f, 4.47206f, 0, 0, 0.786772f, -0.617243f, 999999))
+                                {
+                                    go_flame1->SetPhaseMask(1,true);
+                                }
+                                if (GameObject* go_flame2 = me->SummonGameObject(GO_FLAME_WALLS3, 3154.56f, 535.418f, 72.8889f, 4.47206f, 0, 0, 0.786772f, -0.617243f, 999999))
+                                {
+                                    go_flame2->SetPhaseMask(32,true);
+                                }
+                                break;
+                            case EVENT_CAST_TAIL_LASH:
+                                DoCast(SPELL_TAIL_LASH);
+                                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                                break;
+                            case EVENT_CAST_CLEAVE:
+                                DoCast(SPELL_CLEAVE);
+                                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                                break;
+                            case EVENT_METEOR_STRIKE:
+                                MeteorStrike();
+                                events.ScheduleEvent(EVENT_METEOR_STRIKE, 20000);
+                                break;
+                            case EVENT_CAST_FLAME_BREATH:
+                                DoCast(RAID_MODE(SPELL_FLAME_BREATH_10_NORMAL, SPELL_FLAME_BREATH_25_NORMAL, SPELL_FLAME_BREATH_10_HEROIC, SPELL_FLAME_BREATH_25_HEROIC));
+                                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000));break;
+                            case EVENT_DPS:
+                                CastCorporeality();
+                                events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                                break;
+                            case EVENT_CAST_FIERY_COMBUSTION:
+                                Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM,0);
+                                if (pTarget && !pTarget->HasAura(SPELL_FIERY_COMBUSTION))
+                                    DoCast(pTarget, SPELL_FIERY_COMBUSTION);
+                                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000);
+                                break;
+                        }
+                    }
+                }
+
+               /* if ((events.GetPhaseMask() & PHASE_1_MASK) && me->HealthBelowPct(75))
+                {
+                    events.SetPhase(PHASE_2);
+                    instance->SetBossState(DATA_HALION, SPECIAL);
+                    DoScriptText(SAY_PHASE2, me);
+                    DoCast(me, SPELL_SUMMON_TWILIGHT_PORTAL);
+                    DoCast(me, SPELL_TWILIGHT_DIVISION);
+                    me->SummonCreature(NPC_TWILIGHT_HALION,SpawnPosHalion);
+                    me->SetReactState(REACT_PASSIVE);
+                    me->AttackStop();
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    me->SetVisible(false);
+                }*/
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            uint32 PercentDamage;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_halionAI(pCreature);
+        }
+
+};
+
+class boss_twilight_halion : public CreatureScript
+{
+    public:
+        boss_twilight_halion() : CreatureScript("boss_twilight_halion") { }
+
+        struct boss_twilight_halionAI : public ScriptedAI
+        {
+            boss_twilight_halionAI(Creature *pCreature) : ScriptedAI(pCreature)
+                {
+                    pInstance = me->GetInstanceScript();
+                    pTwilight = me;
+                }
+
+            void Reset()
+            {
+                if (pInstance->GetBossState(DATA_HALION)!=SPECIAL)
+                    return;
+                me->SetReactState(REACT_AGGRESSIVE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                events.Reset();
+                events.SetPhase(PHASE_2);
+                events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1000);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000));
+                events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000));
+                events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000));
+                events.ScheduleEvent(EVENT_CAST_BERSEK, 9999999);
+                me->SetMaxHealth(pHalion->GetMaxHealth());
+                TwilightDamage = 0;
+            }
+
+            void EnterCombat(Unit*)
+            {
+                me->SetHealth(pHalion->GetHealth());
+                pInstance->SetData(DATA_TWILIGHT_HALION,IN_PROGRESS);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (pInstance->GetData(DATA_DAMAGE) != 0)
+                        me->SetHealth(pInstance->GetData(DATA_DAMAGE));
+                    else
+                        me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_TWILIGHT_PRECISION:
+                            DoCast(me, SPELL_TWILIGHT_PRECISION);
+                            break;
+                        case EVENT_CAST_TAIL_LASH:
+                            DoCast(SPELL_TAIL_LASH);
+                            events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                            break;
+                        case EVENT_CAST_DARK_BREATH:
+                            DoCast(RAID_MODE(SPELL_DARK_BREATH_10_NORMAL, SPELL_DARK_BREATH_25_NORMAL, SPELL_DARK_BREATH_10_HEROIC, SPELL_DARK_BREATH_25_HEROIC));
+                            events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000));break;
+                        case EVENT_CAST_CLEAVE:
+                            DoCast(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                            break;
+                        case EVENT_CAST_DUSK_SHROUD:
+                            DoCastAOE(SPELL_DUSK_SHROUD,true);
+                            events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000));
+                            break;
+                        case EVENT_CAST_SOUL_CONSUMPTION:
+                            DoCast(SPELL_SOUL_CONSUMPTION);
+                            events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000));
+                            break;
+                        case EVENT_CAST_BERSEK:
+                            DoCast(me, SPELL_BERSEK);
+                            events.ScheduleEvent(EVENT_CAST_BERSEK, 600000);
+                            break;
+                        case EVENT_DPS:
+                            if (pInstance->GetBossState(DATA_HALION)==SPECIAL)
+                                CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->CastCorporeality();
+                            events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                            break;
+                    }
+                }
+
+                if ((events.GetPhaseMask() & PHASE_2_MASK) && me->HealthBelowPct(50))
+                {
+                    pInstance->SetData(DATA_DAMAGE, me->GetHealth());
+                    events.SetPhase(PHASE_3);
+                    DoScriptText(SAY_PHASE3, me);
+                    pHalion->SetReactState(REACT_AGGRESSIVE);
+                    pHalion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    pHalion->SetVisible(true);
+                    CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->SetPhase3();
+                    events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+            void DamageTaken(Unit* /*who*/, uint32 &dmg)
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                TwilightDamage += dmg;    
+
+                pInstance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustReachedHome()
+            {
+                pInstance->SetData(DATA_TWILIGHT_HALION, FAIL);
+                if (pInstance->GetBossState(DATA_HALION)==SPECIAL)
+                    pInstance->SetBossState(DATA_HALION,FAIL);
+                CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->Reset();
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+                me->ForcedDespawn(10);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+            }
+
+            void JustDied(Unit*)
+            {
+                pInstance->SetData(DATA_TWILIGHT_HALION,DONE);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+            }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_twilight_halionAI(pCreature);
+        }
+
+};
+
+class spell_halion_portal : public SpellScriptLoader
+{
+    public:
+        spell_halion_portal() : SpellScriptLoader("spell_halion_portal") { }
+
+        class spell_halion_portal_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_halion_portal_SpellScript)
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                PreventHitDefaultEffect(EFFECT_0);
+                GetHitPlayer()->RemoveAurasDueToSpell(SPELL_AURE_TWILIGHT);
+                GetHitPlayer()->SetPhaseMask(1,true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_halion_portal_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_APPLY_AURA);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_portal_SpellScript();
+        }
+};
+
+class npc_meteor_strike : public CreatureScript
+{
+    public:
+        npc_meteor_strike() : CreatureScript("npc_meteor_strike") { }
+
+        struct npc_meteor_strikeAI : public ScriptedAI
+        {
+            npc_meteor_strikeAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                DoCast(me, SPELL_METEOR_STRIKE);
+                events.Reset();
+                events.ScheduleEvent(EVENT_METEOR_DAMAGE, 7000);
+                events.ScheduleEvent(EVENT_METEOR_STRIKE, 1000);
+                me->ForcedDespawn(15000);
+                angle = (float)(urand(0,62)/10);
+                dist = 0;
+                count = 0;
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_METEOR_STRIKE:
+                            DoCastAOE(SPELL_METEOR_TARGET);
+                            break;
+                        case EVENT_METEOR_DAMAGE:
+                            DoCastAOE(SPELL_METEOR_DAMAGE);
+                            events.ScheduleEvent(EVENT_METEOR_FLAME, 1000);
+                            break;
+                        case EVENT_METEOR_FLAME:
+                            float x, y;
+                            dist += 5;
+                            count ++;
+                            me->GetNearPoint2D(x, y, dist, angle);
+                            me->SummonCreature(NPC_METEOR_STRIKE_EAST,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            me->GetNearPoint2D(x, y, dist, angle+M_PI);
+                            me->SummonCreature(NPC_METEOR_STRIKE_EAST,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            me->GetNearPoint2D(x, y, dist, angle+3*M_PI/2);
+                            me->SummonCreature(NPC_METEOR_STRIKE_EAST,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            me->GetNearPoint2D(x, y, dist, angle+M_PI/2);
+                            me->SummonCreature(NPC_METEOR_STRIKE_EAST,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            if (count < 8)
+                                events.ScheduleEvent(EVENT_METEOR_FLAME, 1000);
+                            break;
+                    }
+                }
+            }
+
+        private:
+            EventMap events;
+            float dist, angle;
+            uint8 count;
+
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_meteor_strikeAI(pCreature);
+        }
+};
+
+class npc_spell_meteor_strike : public CreatureScript
+{
+    public:
+        npc_spell_meteor_strike() : CreatureScript("npc_spell_meteor_strike") { }
+
+        struct npc_spell_meteor_strikeAI : public ScriptedAI
+        {
+            npc_spell_meteor_strikeAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                me->ForcedDespawn(10000);
+            }
+
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_spell_meteor_strikeAI(pCreature);
+        }
+};
+
+class npc_meteor_flame : public CreatureScript
+{
+    public:
+        npc_meteor_flame() : CreatureScript("npc_meteor_flame") { }
+
+        struct npc_meteor_flameAI : public ScriptedAI
+        {
+            npc_meteor_flameAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                DoCast(me,SPELL_METEOR_FLAME);
+ 
+                me->ForcedDespawn(10000);
+            }
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_meteor_flameAI(pCreature);
+        }
+};
+
+class npc_summon_halion : public CreatureScript
+{
+    public:
+        npc_summon_halion() : CreatureScript("npc_summon_halion") { }
+
+        struct npc_summon_halionAI : public ScriptedAI
+        {
+            npc_summon_halionAI(Creature *pCreature) : ScriptedAI(pCreature)
+            { 
+                pInstance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                events.Reset();
+                events.ScheduleEvent(EVENT_FIRE_PILLAR, 10000);
+                DoCast(me,SPELL_FIRE_PILLAR);
+ 
+                me->ForcedDespawn(20000);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_FIRE_PILLAR:
+                            Creature *pHalion = pInstance->instance->GetCreature(pInstance->GetData64(DATA_HALION));
+                            if(pHalion)
+                            {
+                                DoCastAOE(SPELL_FIERY_EXPLOSION);
+                                pHalion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                pHalion->SetVisible(true);
+                                pHalion->SetReactState(REACT_AGGRESSIVE);
+                            }
+                            break;
+                    }
+                }
+            }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_summon_halionAI(pCreature);
+        }
+};
+
+class npc_combustion : public CreatureScript
+{
+public:
+    npc_combustion() : CreatureScript("npc_combustion") { }
+
+    struct npc_combustionAI : public ScriptedAI
+    {
+            npc_combustionAI(Creature *pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = me->GetInstanceScript();
+            }
+
+            InstanceScript* pInstance;
+            
+            uint32 Duration;
+
+            void Reset()
+            {
+                Duration = 10000;
+                
+                me->SetReactState(REACT_PASSIVE);
+                if (!me->HasAura(SPELL_ROOT))
+                    DoCast(me, SPELL_ROOT);
+                if (!me->HasAura(SPELL_COMBUSTION))
+                    DoCast(me, SPELL_COMBUSTION);
+            }
+            
+            void JustDied(Unit* )
+            {
+                me->RemoveAura(SPELL_COMBUSTION);
+            }
+            
+            void UpdateAI(const uint32 diff)
+            {
+                if(!UpdateVictim())
+                    return;
+                    
+                if (Duration <= diff)
+                {
+                    me->ForcedDespawn();
+                } else Duration -= diff;
+
+                DoMeleeAttackIfReady();
+            }
+    };
+
+    CreatureAI* GetAI(Creature *pCreature) const
+    {
+            return new npc_combustionAI(pCreature);
+    }
+
+};
+
+void AddSC_boss_halion()
+{
+    new boss_halion();
+    new boss_twilight_halion();
+    new spell_halion_portal();
+    new npc_meteor_strike();
+    new npc_spell_meteor_strike();
+    new npc_meteor_flame();
+    new npc_summon_halion();
+    new npc_combustion();
+}
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
index ca65090..0629832 100644
--- a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/instance_ruby_sanctum.cpp
@@ -46,6 +46,9 @@ class instance_ruby_sanctum : public InstanceMapScript
                 BaltharusSharedHealth   = 0;
                 FlameWallsGUID          = 0;
                 FlameRingGUID           = 0;
+		TwilightHalionGUID	= 0;
+		HalionPortalGUID	= 0;
+                TwilightPortalGUID	= 0;
                 memset(ZarithianSpawnStalkerGUID, 0, 2*sizeof(uint64));
                 memset(BurningTreeGUID, 0, 4*sizeof(uint64));
             }
@@ -65,9 +68,26 @@ class instance_ruby_sanctum : public InstanceMapScript
                         break;
                     case NPC_HALION:
                         HalionGUID = creature->GetGUID();
+			if (GetBossState(NPC_GENERAL_ZARITHRIAN)==DONE)
+                        {
+                            creature->SetVisible(true);
+                            creature->SetReactState(REACT_AGGRESSIVE);
+                            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                            creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE); 
+                        }
+                        else
+                        {
+                            creature->SetVisible(false);
+                            creature->SetReactState(REACT_PASSIVE);
+                            creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
                         break;
+		    case NPC_HALION_TWILIGHT:
+			TwilightHalionGUID = creature->GetGUID();
+			break;
                     case NPC_HALION_CONTROLLER:
-                        HalionControllerGUID = creature->GetGUID();
+                        HalionGUID = creature->GetGUID();
+                        break;
                     case NPC_BALTHARUS_TARGET:
                         CrystalChannelTargetGUID = creature->GetGUID();
                         break;
@@ -99,6 +119,8 @@ class instance_ruby_sanctum : public InstanceMapScript
                         break;
                     case GO_FLAME_RING:
                         FlameRingGUID = go->GetGUID();
+			if (GetBossState(DATA_HALION) == DONE)
+			    HandleGameObject(FlameRingGUID, true);
                         break;
                     case GO_BURNING_TREE_1:
                         BurningTreeGUID[0] = go->GetGUID();
@@ -120,6 +142,12 @@ class instance_ruby_sanctum : public InstanceMapScript
                         if (GetBossState(DATA_GENERAL_ZARITHRIAN) == DONE)
                             HandleGameObject(BurningTreeGUID[3], true);
                         break;
+		    case GO_HALION_PORTAL_1:
+			HalionPortalGUID = go->GetGUID();
+			break;
+		    case GO_HALION_PORTAL_EXIT:
+			TwilightPortalGUID = go->GetGUID();
+			break;
                     default:
                         break;
                 }
@@ -169,6 +197,9 @@ class instance_ruby_sanctum : public InstanceMapScript
                         return BurningTreeGUID[3];
                     case DATA_FLAME_RING:
                         return FlameRingGUID;
+		    case DATA_TWILIGHT_HALION:
+			return TwilightHalionGUID;
+			break;
                     default:
                         break;
                 }
@@ -184,7 +215,6 @@ class instance_ruby_sanctum : public InstanceMapScript
                 switch (type)
                 {
                     case DATA_BALTHARUS_THE_WARBORN:
-                    {
                         if (state == DONE && GetBossState(DATA_SAVIANA_RAGEFIRE) == DONE)
                         {
                             HandleGameObject(FlameWallsGUID, true);
@@ -192,9 +222,7 @@ class instance_ruby_sanctum : public InstanceMapScript
                                 zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
                         }
                         break;
-                    }
                     case DATA_SAVIANA_RAGEFIRE:
-                    {
                         if (state == DONE && GetBossState(DATA_BALTHARUS_THE_WARBORN) == DONE)
                         {
                             HandleGameObject(FlameWallsGUID, true);
@@ -202,14 +230,39 @@ class instance_ruby_sanctum : public InstanceMapScript
                                 zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
                         }
                         break;
-                    }
                     case DATA_GENERAL_ZARITHRIAN:
                         if (GetBossState(DATA_SAVIANA_RAGEFIRE) == DONE && GetBossState(DATA_BALTHARUS_THE_WARBORN) == DONE)
                             HandleGameObject(FlameWallsGUID, state != IN_PROGRESS);
                         if (state == DONE)
-                            if (Creature* halionController = instance->SummonCreature(NPC_HALION_CONTROLLER, HalionControllerSpawnPos))
-                                halionController->AI()->DoAction(ACTION_INTRO_HALION);
+                            if (Creature* halion = instance->GetCreature(GetData64(DATA_HALION)))
+			    {
+				halion->SummonCreature(NPC_SUMMON_HALION, HalionControllerSpawnPos,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,20000);
+				halion->SetVisible(true);
+                                halion->SetReactState(REACT_AGGRESSIVE);
+                                halion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                halion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+			     }
                         break;
+		    case DATA_HALION:
+                        if (state==DONE)
+                        {
+                            if (GameObject* flame2 = instance->GetGameObject(GetData64(GO_FLAME_RING)))
+                                flame2->RemoveFromWorld();
+
+                            if (GameObject* flame3 = instance->GetGameObject(GetData64(GO_FLAME_WALLS3)))
+                                flame3->RemoveFromWorld();
+                        }
+			    if (GetBossState(DATA_GENERAL_ZARITHRIAN)==DONE)
+                        {
+                            if (Creature* halion = instance->GetCreature(GetData64(DATA_HALION)))
+                            {
+                                halion->SetVisible(true);
+                                halion->SetReactState(REACT_AGGRESSIVE);
+                                halion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                halion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                            }
+                         }
+                         break;
                     default:
                         break;
                 }
@@ -297,6 +350,9 @@ class instance_ruby_sanctum : public InstanceMapScript
             uint64 BurningTreeGUID[4];
             uint64 FlameRingGUID;
             uint32 BaltharusSharedHealth;
+	    uint64 TwilightHalionGUID;
+	    uint64 HalionPortalGUID;
+	    uint64 TwilightPortalGUID;
         };
 
         InstanceScript* GetInstanceScript(InstanceMap* map) const
diff --git a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.h b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.h
index 0acffc5..5912f30 100644
--- a/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.h
+++ b/src/server/scripts/Northrend/ChamberOfAspects/RubySanctum/ruby_sanctum.h
@@ -47,6 +47,16 @@ enum DataTypes
     DATA_BURNING_TREE_3                     = 12,
     DATA_BURNING_TREE_4                     = 13,
     DATA_FLAME_RING                         = 14,
+    DATA_TWILIGHT_HALION 		    = 15,
+    DATA_DAMAGE				    = 16,
+};
+
+enum eAchievementData
+{
+    TWILIGHT_DESTROYER_NORMAL_10    = 4817,
+    TWILIGHT_DESTROYER_NORMAL_25    = 4815,
+    TWILIGHT_DESTROYER_HEROIC_10    = 4818,
+    TWILIGHT_DESTROYER_HEROIC_25    = 4816
 };
 
 enum SharedActions
@@ -84,8 +94,9 @@ enum CreaturesIds
     NPC_METEOR_STRIKE_NORTH                 = 40041,
     NPC_METEOR_STRIKE_EAST                  = 40042,
     NPC_METEOR_STRIKE_WEST                  = 40043,
-    NPC_METEOR_STRIKE_SOUTH                 = 40044,
+    NPC_SUMMON_HALION	                    = 40044,
     NPC_METEOR_STRIKE_FLAME                 = 40055,
+    NPC_COMBUSTION 			    = 40001,
 
     // Xerestrasza
     NPC_XERESTRASZA                         = 40429,
@@ -103,6 +114,7 @@ enum GameObjectsIds
     GO_BURNING_TREE_2                       = 203035,
     GO_BURNING_TREE_3                       = 203036,
     GO_BURNING_TREE_4                       = 203037,
+    GO_FLAME_WALLS3     		    = 203624,
 };
 
 enum WorldStatesRS
